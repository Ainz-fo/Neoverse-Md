/*const { zokou } = require('../framework/zokou');
const duels = new Map(); // Stocke les duels en cours

// Liste des ar√®nes
const arenes = [
    { nom: 'plaine vide', image: 'https://i.ibb.co/3h71nT1/image.jpg' },
    { nom: 'Desert', image: 'https://i.ibb.co/z2gwsMQ/image.jpg' },
    { nom: 'Zone de glace', image: 'https://i.ibb.co/3F0mK1s/image.jpg' },
    { nom: 'Vall√©e de la fin', image: 'https://i.ibb.co/VqFgGzF/image.jpg' },
    { nom: 'Au dela', image: 'https://i.ibb.co/4Wkr6mT/image.jpg' },
    { nom: 'Budokai tenkaichi', image: 'https://i.ibb.co/B429M3M/image.jpg' },
    { nom: 'ville de jour', image: 'https://i.ibb.co/LRDRH9k/image.jpg' },
    { nom: 'Ville detruite', image: 'https://i.ibb.co/80R07hR/image.jpg' }
];

// Fonction pour tirer une ar√®ne al√©atoire
function tirerAr() {
    return arenes[Math.floor(Math.random() * arenes.length)];
}

// G√©n√®re un ID unique √† partir de deux chiffres
function genererID() {
    let id;
    do {
        id = Math.floor(Math.random() * 21); // G√©n√®re un nombre entre 10 et 99
    } while (duels.has(id)); // S'assure que l'ID n'est pas d√©j√† utilis√©
    return id;
}

// Fonction pour supprimer un duel
function supprimerDuel(id) {
    duels.delete(id);
}

// Fonction pour r√©cup√©rer un r√©capitulatif des duels en cours
function recupDuel() {
    if (duels.size === 0) return "Aucun duel en cours.";
    let recap = "*üîπ Duels en cours :*\n";
    duels.forEach((_, id) => {
        recap += `- Duel ID: ${id}\n`;
    });
    return recap;
}

zokou(
    {
        nomCom: 'duel',
        categorie: 'Other'
    },
    async (dest, zk, commandeOptions) => {
        const { repondre, arg, ms } = commandeOptions;

        if (arg[0] === "del") {
            // Suppression d'un duel
            const id = parseInt(arg[1], 10);
            if (duels.has(id)) {
                supprimerDuel(id);
                await repondre(`Le duel ID: ${id} a √©t√© supprim√©.`);
            } else {
                await repondre("Aucun duel trouv√© avec cet ID.");
            }
            return;
        } else if (arg[0] === "list") {
            // R√©capitulatif des duels en cours
            const recap = recupDuel();
            await repondre(recap);
            return;
        } else if (!isNaN(arg[0])) {
            // Gestion de la r√©cup√©ration d'un duel par ID
            const duelID = parseInt(arg[0], 10);
            if (duels.has(duelID)) {
                const duel = duels.get(duelID);
                let ficheDuel = `*üÜöùó©ùóòùó•ùó¶ùó®ùó¶ ùóîùó•ùóòùó°ùóî ùóïùóîùóßùóßùóüùóòüèÜüéÆ*
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n`;
                
                // Ajouter les joueurs de l'√©quipe 1 avec leurs statistiques
                duel.equipe1.forEach((joueur) => {
                    ficheDuel += `üî∑ *${joueur}*: ü´Ä:100% üåÄ:100% ‚ù§Ô∏è:100%\n`;
                });

                ficheDuel += `                                   ~  *üÜö*  ~\n`;

                // Ajouter les joueurs de l'√©quipe 2 avec leurs statistiques
                duel.equipe2.forEach((joueur) => {
                    ficheDuel += `üî∑ *${joueur}*: ü´Ä:100% üåÄ:100% ‚ù§Ô∏è:100%\n`;
                });

                // Ajouter les infos sur l'ar√®ne tir√©e
                ficheDuel += `‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*üåçùêÄùê´ùêûÃÄùêßùêû*: ${duel.arene.nom}
*üö´ùêáùêöùêßùêùùê¢ùêúùêöùê©ùêû*: Boost 1 fois chaque 2 tours!
*‚öñÔ∏èùêíùê≠ùêöùê≠ùê¨*: ${duel.stats}
*üèûÔ∏è ùêÄùê¢ùê´ ùêùùêû ùêúùê®ùê¶ùêõùêöùê≠*: illimit√©e
*ü¶∂üèºùêÉùê¢ùê¨ùê≠ùêöùêßùêúùêû ùê¢ùêßùê¢ùê≠ùê¢ùêöùê•ùêû*üìå: 5m
*‚åöùêãùêöùê≠ùêûùêßùêúùêû*: 6mins+ 1‚ö†Ô∏è
*‚≠ïùêèùê®ùê´ùê≠ùêûÃÅùêû*: 10m\n‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*‚ö†Ô∏èVous avez üîü tours max pour finir votre Adversaire! Sinon la victoire sera donn√©e par d√©cision selon celui qui a domin√© le combat ou qui a √©t√© le plus offensif !*
`;

                // Envoyer l'image avec le texte de la fiche de duel
                await zk.sendMessage(dest, { image: { url: duel.arene.image }, caption: ficheDuel }, { quoted: ms });
            } else {
                await repondre(`Aucun duel trouv√© avec l'ID : ${duelID}`);
            }
            return;
        }

        // Gestion d'un nouveau duel
        const input = arg.join(' ');
        const [joueursInput, statsCustom] = input.split('/').map(part => part.trim());
        const [joueursAvantVs, joueursApresVs] = joueursInput.split('vs').map(part => part.trim());

        const equipe1 = joueursAvantVs.split(',').map(joueur => joueur.trim());
        const equipe2 = joueursApresVs.split(',').map(joueur => joueur.trim());

        // Tirer une ar√®ne al√©atoire
       const areneT = tirerAr();

        // G√©n√©rer un ID unique pour le duel
        const duelID = genererID();
        repondre(`üîë Votre cl√© d'acc√®s au duel est : *${duelID}*`);

        // Stocker le duel en cours
        duels.set(duelID, { equipe1, equipe2, arene: areneT, stats: statsCustom });

        // G√©n√©rer la fiche de duel
        let ficheDuel = `*üÜöùó©ùóòùó•ùó¶ùó®ùó¶ ùóîùó•ùóòùó°ùóî ùóïùóîùóßùóßùóüùóòüèÜüéÆ*
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n`;
        equipe1.forEach((joueur) => {
            ficheDuel += `üî∑ *${joueur}*: ü´Ä:100% üåÄ:100% ‚ù§Ô∏è:100%\n`;
        });

        ficheDuel += `                                   ~  *üÜö*  ~\n`;
        equipe2.forEach((joueur) => {
            ficheDuel += `üî∑ *${joueur}*: ü´Ä:100% üåÄ:100% ‚ù§Ô∏è:100%\n`;
        });

        ficheDuel += `‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*üåçùêÄùê´ùêûÃÄùêßùêû*: ${areneT.nom}
*üö´ùêáùêöùêßùêùùê¢ùêúùêöùê©ùêû*: Boost 1 fois chaque 2 tours!
*‚öñÔ∏èùêíùê≠ùêöùê≠ùê¨*: ${statsCustom}
*üèûÔ∏è ùêÄùê¢ùê´ ùêùùêû ùêúùê®ùê¶ùêõùêöùê≠*: illimit√©e
*ü¶∂üèºùêÉùê¢ùê¨ùê≠ùêöùêßùêúùêû ùê¢ùêßùê¢ùê≠ùê¢ùêöùê•ùêû*üìå: 5m
*‚åöùêãùêöùê≠ùêûùêßùêúùêû*: 6mins+ 1‚ö†Ô∏è
*‚≠ïùêèùê®ùê´ùê≠ùêûÃÅùêû*: 10m\n‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*‚ö†Ô∏èVous avez üîü tours max pour finir votre Adversaire! Sinon la victoire sera donn√©e par d√©cision selon celui qui a domin√© le combat ou qui a √©t√© le plus offensif !*
`;

        await zk.sendMessage(dest, { image: { url: areneT.image }, caption: ficheDuel }, { quoted: ms });
    }
);*/







// bot.js
const { zokou } = require('../framework/zokou');
const { sauvegarderDuel, restaurerDuels, supprimerDuel } = require('../bdd/duel');
const duels = new Map(); // Stocke les duels en cours

// Liste des ar√®nes
const arenes = [
    { nom: 'plaine vide', image: 'https://i.ibb.co/3h71nT1/image.jpg' },
    { nom: 'Desert', image: 'https://i.ibb.co/z2gwsMQ/image.jpg' },
    { nom: 'Zone de glace', image: 'https://i.ibb.co/3F0mK1s/image.jpg' },
    { nom: 'Vall√©e de la fin', image: 'https://i.ibb.co/VqFgGzF/image.jpg' },
    { nom: 'Au dela', image: 'https://i.ibb.co/4Wkr6mT/image.jpg' },
    { nom: 'Budokai tenkaichi', image: 'https://i.ibb.co/B429M3M/image.jpg' },
    { nom: 'ville de jour', image: 'https://i.ibb.co/LRDRH9k/image.jpg' },
    { nom: 'Ville detruite', image: 'https://i.ibb.co/80R07hR/image.jpg' }
];

// Fonction pour tirer une ar√®ne al√©atoire
function tirerAr() {
    return arenes[Math.floor(Math.random() * arenes.length)];
}

// G√©n√®re un ID unique √† partir de deux chiffres
function genererID() {
    let id;
    do {
        id = Math.floor(Math.random() * 10000); // G√©n√®re un nombre entre 0 et 9999
    } while (duels.has(id)); // S'assure que l'ID n'est pas d√©j√† utilis√©
    return id;
}

// Fonction pour r√©cup√©rer un r√©capitulatif des duels en cours
function recupDuel() {
    if (duels.size === 0) return "Aucun duel en cours.";
    let recap = "*üîπ Duels en cours :*\n";
    duels.forEach((_, id) => {
        recap += `- Duel ID: ${id}\n`;
    });
    return recap;
}

// Fonction pour mettre √† jour les statistiques d'un joueur
function modifierStats(joueur, statsModifications) {
    statsModifications.forEach(({ stat, operation, valeur }) => {
        joueur.stats[stat] = operation === '+' 
            ? joueur.stats[stat] + valeur
            : joueur.stats[stat] - valeur;
    });
}

// Fonction pour extraire les modifications de statistiques
function extraireModifications(args) {
    const modifications = [];
    for (let i = 0; i < args.length; i += 3) {
        const joueur = args[i];
        const stat = args[i + 1];
        const operationValeur = args[i + 2];
        const operation = operationValeur[0];
        const valeur = parseInt(operationValeur.slice(1), 10);
        modifications.push({ joueur, stat, operation, valeur });
    }
    return modifications;
}

zokou(
    {
        nomCom: 'duel',
        categorie: 'Other'
    },
    async (dest, zk, commandeOptions) => {
        const { repondre, arg, ms } = commandeOptions;
        let client;
        if (arg[0] === "del") {
            // Suppression d'un duel
            const id = parseInt(arg[1], 10);
            if (duels.has(id)) {
                duels.delete(id);
                await supprimerDuel(id);
                await repondre(`Le duel ID: ${id} a √©t√© supprim√©.`);
            } else {
                await repondre("Aucun duel trouv√© avec cet ID.");
            }
            return;
        } else if (arg[0] === "list") {
            // R√©capitulatif des duels en cours
            const recap = recupDuel();
            await repondre(recap);
            return;
        } else if (!isNaN(arg[arg.length - 1])) {
            // Gestion de la mise √† jour des statistiques par ID
            const duelID = parseInt(arg[arg.length - 1], 10);
            if (duels.has(duelID)) {
                const duel = duels.get(duelID);

                // Extraire les modifications de statistiques
                const modifications = extraireModifications(arg.slice(0, arg.length - 1));

                // Appliquer les modifications aux joueurs concern√©s
                modifications.forEach(({ joueur, stat, operation, valeur }) => {
                    let cible = duel.equipe1.find(j => j.nom === joueur) || duel.equipe2.find(j => j.nom === joueur);
                    if (cible) {
                        modifierStats(cible, [{ stat, operation, valeur }]);
                    }
                });

                // G√©n√©rer la fiche de duel mise √† jour
                let ficheDuel = `*üÜöùó©ùóòùó•ùó¶ùó®ùó¶ ùóîùó•ùóòùó°ùóî ùóïùóîùóßùóßùóüùóòüèÜüéÆ*\n`;
                
                duel.equipe1.forEach(joueur => {
                    ficheDuel += `üî∑ *${joueur.nom}*: ü´Ä:${joueur.stats.sta}% üåÄ:${joueur.stats.energie}% ‚ù§Ô∏è:${joueur.stats.vie}%\n`;
                });

                ficheDuel += `                                   ~  *üÜö*  ~\n`;

                duel.equipe2.forEach(joueur => {
                    ficheDuel += `üî∑ *${joueur.nom}*: ü´Ä:${joueur.stats.sta}% üåÄ:${joueur.stats.energie}% ‚ù§Ô∏è:${joueur.stats.vie}%\n`;
                });

                ficheDuel += `‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*üåçùêÄùê´ùêûÃÄùêßùêû*: ${duel.arene.nom}
*üö´ùêáùêöùêßùêùùê¢ùêúùêöùê©ùêû*: Boost 1 fois chaque 2 tours!
*‚öñÔ∏èùêíùê≠ùêöùê≠ùê¨*: ${statsCustom}
*üèûÔ∏è ùêÄùê¢ùê´ ùêùùêû ùêúùê®ùê¶ùêõùêöùê≠*: illimit√©e
*ü¶∂üèºùêÉùê¢ùê¨ùê≠ùêöùêßùêúùêû ùê¢ùêßùê¢ùê≠ùê¢ùêöùê•ùêû*üìå: 5m
*‚åöùêãùêöùê≠ùêûùêßùêúùêû*: 6mins+ 1‚ö†Ô∏è
*‚≠ïùêèùê®ùê´ùê≠ùêûÃÅùêû*: 10m\n‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*‚ö†Ô∏èVous avez üîü tours max pour finir votre Adversaire! Sinon la victoire sera donn√©e par d√©cision selon celui qui a domin√© le combat ou qui a √©t√© le plus offensif !*
`;
                // Envoyer la fiche de duel mise √† jour
                await zk.sendMessage(dest, { image: { url: duel.arene.image }, caption: ficheDuel }, { quoted: ms });
            } else {
                await repondre(`Aucun duel trouv√© avec l'ID : ${duelID}`);
            }
            return;
        }

        // Gestion d'un nouveau duel
        const input = arg.join(' ');
        const [joueursInput, statsCustom] = input.split('/').map(part => part.trim());
        const [joueursAvantVs, joueursApresVs] = joueursInput.split('vs').map(part => part.trim());

        const equipe1 = joueursAvantVs.split(',').map(joueur => ({ nom: joueur.trim(), stats: { sta: 100, energie: 100, vie: 100 } }));
        const equipe2 = joueursApresVs.split(',').map(joueur => ({ nom: joueur.trim(), stats: { sta: 100, energie: 100, vie: 100 } }));
        // Tirer une ar√®ne al√©atoire
const areneT = tirerAr();

// G√©n√©rer un ID unique pour le duel
const duelID = genererID();
repondre(`üîë Votre cl√© d'acc√®s au duel est : *${duelID}*`);

// Stocker le duel en cours
duels.set(duelID, { equipe1, equipe2, arene: areneT, stats: statsCustom });

// G√©n√©rer la fiche de duel initiale
let ficheDuel = `*üÜöùó©ùóòùó•ùó¶ùó®ùó¶ ùóîùó•ùóòùó°ùóî ùóïùóîùóßùóßùóüùóòüèÜüéÆ*
‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n`;

equipe1.forEach(joueur => {
    ficheDuel += `üî∑ *${joueur.nom}*: ü´Ä:${joueur.stats.sta}% üåÄ:${joueur.stats.energie}% ‚ù§Ô∏è:${joueur.stats.vie}%\n`;
});

ficheDuel += `                                   ~  *üÜö*  ~\n`;

equipe2.forEach(joueur => {
    ficheDuel += `üî∑ *${joueur.nom}*: ü´Ä:${joueur.stats.sta}% üåÄ:${joueur.stats.energie}% ‚ù§Ô∏è:${joueur.stats.vie}%\n`;
});

ficheDuel += `‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*üåçùêÄùê´ùêûÃÄùêßùêû*: ${areneT.nom}
*üö´ùêáùêöùêßùêùùê¢ùêúùêöùê©ùêû*: Boost 1 fois chaque 2 tours!
*‚öñÔ∏èùêíùê≠ùêöùê≠ùê¨*: ${statsCustom}
*üèûÔ∏è ùêÄùê¢ùê´ ùêùùêû ùêúùê®ùê¶ùêõùêöùê≠*: illimit√©e
*ü¶∂üèºùêÉùê¢ùê¨ùê≠ùêöùêßùêúùêû ùê¢ùêßùê¢ùê≠ùê¢ùêöùê•ùêû*üìå: 5m
*‚åöùêãùêöùê≠ùêûùêßùêúùêû*: 6mins+ 1‚ö†Ô∏è
*‚≠ïùêèùê®ùê´ùê≠ùêûÃÅùêû*: 10m\n‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî‚ñî\n
*‚ö†Ô∏èVous avez üîü tours max pour finir votre Adversaire! Sinon la victoire sera donn√©e par d√©cision selon celui qui a domin√© le combat ou qui a √©t√© le plus offensif !*
`;

// Envoyer la fiche de duel initiale
await zk.sendMessage(dest, { image: { url: areneT.image }, caption: ficheDuel }, { quoted: ms });

// Connexion √† la base de donn√©es PostgreSQL
const { Pool } = require("pg");

const s = require("../set");

var dbUrl = s.DB;
const proConfig = {
  connectionString: dbUrl,
  ssl: {
    rejectUnauthorized: false,
  },
};

const pool = new Pool(proConfig);

client = await pool.connect();

// Enregistrement des d√©tails du duel dans la base de donn√©es
const queryText = `
    INSERT INTO duels (duel_id, equipe1, equipe2, arene)
    VALUES ($1, $2, $3, $4)
`;
const values = [duelID, JSON.stringify(equipe1), JSON.stringify(equipe2), areneT.nom];

try {
    await client.query(queryText, values);
    console.log(`Duel ${duelID} enregistr√© dans la base de donn√©es`);
} catch (err) {
    console.error('Erreur lors de l\'enregistrement du duel:', err);
} finally {
    client.release(); // Lib√©rer la connexion proprement
}
    });
